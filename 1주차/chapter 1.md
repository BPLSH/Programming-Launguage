Chapter 1
=========

### ***Reasons for Studying Concepts of Programming*** ###
> 개발자가 알고 있는 언어가 한정적이면 소프트웨어 개발에 있어서 제한적이다.  
> 알고 있는 언어에 따라 생각을 표현할 수 있는 능력이 정해지기 때문이다.  
> 프로그래머는 새로운 언어 구조를 배워서 소프트웨어 개발에 대한 사고를 향상시켜야 한다.  
> 프로젝트를 진행할 때, 적합한 새로운 언어를 사용할 수 있다.  
> 많은 언어를 알고 있으면 프로젝트에 맞는 언어를 적용하여 최적화된 결과를 도출할 수 있다.  
> 새로운 언어를 배우는 과정을 통해, 언어의 기본적인 개념들을 완벽히 이해할 수 있으며  
> 기존에 알고 있던 언어에 대한 이해도가 높아지는 부수 효과도 얻는다.  
> 언어 구현의 원리를 깨우치면서 언어를 보다 지능적으로 사용할 수 있는 능력을 깨우친다.  
> 전반적으로 전자계산 분야의 수준이 향상된다.  

### ***Programming Domains*** ###

**과학 응용 분야**
 * 부동소수점에 대한 산술연산을 필요로 함
 * Fortran
**사무 응용 분야**
 * 상세한 보고서를 생성할 수 있는 특징, 십진수와 문자 데이터를 세밀하게 표현 가능
 * cobol
**인공지능 분야**
 * 수치계산x 기호계산o(숫자보다는 이름으로 구성된 기호가 조작된다는 것을 말한다.)
 * LISP
**시스템 프로그래밍**
 * 시스템 프로그래밍에 사용되는 언어는 빠른 실행을 제공돼야 하기 때문에 저급 언어를 사용
 * 지속적으로 사용되므로 실행 효율성을 지녀야 한다.
 * C언어(unix by c)
**웹 소프트웨어**
 * 다양한 언어 지원

### **Language Evaluation Criteria(언어 평가 기준)** ###

### **Readability(가독성)** ### 
* 프로그램을 얼마나 쉽게 읽고 이해할 수 있느냐.
* 생명 주기(software life cycle)의 개념이 개발되었다. 유지보수를 향상시키기 위해 판독성이 중요

**1. Simplicity<간결성>** 
> *전반적인 단순성(Overall Simplicity)*  
>	* 너무 많은 종류의 문장을 지원하는 언어는 좋지 않다.  
>	* 언어가 지원하는 모든 종류의 문장을 알 수 없다.  
>	* 개발자마다 주로 사용하는 문장이 다르다.  
>	* 그래서 간결하고 꼭 필요한 문장을 지원하는 언어가 좋다.  
>
> *특징 다중성(feature multiplicity)*  
>	* 동일한 기능의 연산 표현 방법이 많을수록 좋지 않다.  
>	* 동일한 기능을 여러 가지 사용하여 이해하기 어려움  
>
> *연산자 중복(operator overloading)*  
>	* 하나의 연산자에 여러 타입의 피연산자를 사용할 수 있다.  
	
**2. Orthogonality<직교성>**  
> * 개념적으로 서로 관련이 없는 부분들은 같이 변경될 필요가 없다.  
> * 직교성이 좋다는 것은 예외성이 적다는 것과 같음  
> * 언어의 모든 구성 요소를 임의로 조합해서 프로그램을 작성할 수 있음  
> * 그러나, 직교성이 너무 강하면 비상식적인 조합이 표현될 수 있음  

**3. Control statements<제어문>**
> * goto문은 가독성에 좋지 않다.  
> * 프로그램을 오가며 읽어야 하므로 이해하기 어렵다.  
> * 대부분의 언어에서 구조적 프로그래밍 지원(if else, while..)  
> * 함수형(functional) 언어가 비교적 직교성이 우수함  
> * ex) static, private, public 등등 (제한자)  

**4. Data types and Structures<데이터 타입과 구조체>**
> * 사용하는 언어에서 충분히 data type이 지원되어야 한다.  
> * 프로그래머가 다양한 자료구조를 data type으로 정의할 수 있어야 한다.  

**5. Syntax<문법>**
> *Identifier(식별자)*  
> * 식별자의 길이에 제한이 있는 경우 가독성이 떨어진다.  
> * 식별자에 특수문자를 사용가능하면 가독성이 좋다.  
>
> *특수 단어(Special words)  
> * 의미를 자연스럽게 알 수 있는 특수 단어들은 가독성을 높인다.  
> * ex) if, while, for, then, else 등등  

> *Form and meaning(형식과 의미)*
> * 표현 형식은 같거나 비슷한데 경우에 따라 다른 의미를 가지면 가독성이 떨어진다.
> * ex) C언어에서 static이 전역변수를 정의하는데 사용할 수도 있고, 함수 내에서 지역변수로 사용가능 할 수도 있다.

### **Writability(작성력)** ###
> 새로운 프로그램을 쉽게 작성할 수 있는가?
**1. Simplicity<간결성>**  
> 소수의 구성 요소 (constructs, primitives)  
> 구성 요소들의 조합에 대한 소수의 규칙  

**2. Orthogonality<직교성>**  
> 모든 구성 요소의 임의의 조합이 가능하므로 작성력이 굉장히 좋다.  
> 단, 판독성에서는 지나치면 안좋을 수 있음  

**3. Abstraction<추상화>**
> *데이터의 추상화(Data abstraction)*
> * 복잡한 자료구조를 정의해서 사용할 수 있는 기능 지원
> * ex)  
> C++내에서 stack, queue, tree, graph 등 복잡한 자료구조를 클래스 안에 개발자가 직접 정의하여 사용 가능  
> 그러나, C에서는 클래스 개념이 없어 서로 연관되어 있음을 알 수 없다.
> *프로세스의 추상화(Process abstraction)*
> 복잡한 연산(operation)을 정의하여 사용할 수 있는 기능 지원
> ex)function, procedure

**4. Expressivity<표현력>**
> 기존의 구성 요소와 동일한 기능을 수행하지만 좀 더 편리한 구문 지원  
> ex)switch : 중첩된 if-then-else, for : counter을 사용하는 while, k++/++k/k+=1/k=k+1  
> APL 언어는 매우 강력한 연산자를 지원한다.  
> 행렬 더하기, 곱하기 등이 하나의 연산으로 가능  
> 작성력은 매우 뛰어나나, 가독성이 매우 떨어짐  
> ex)행렬 A와 B 곱하기 : A +.x B  
  
### **Reliability(신뢰성)** ###
> 모든 조건에서 프로그램이 정확하게 실행되는가?
> **1. Type checking**  
> type error는 일찍 발견할수록 수정 비용이 적기 때문에 compile할 때 발견하는 것이 바람직하다.  
>
> **2. Exception handling(예외처리)**  
> 예외처리를 통해 프로그램 실행 시 런_타임_에러가 발생하였다하더라도,  
> 프로그램은 중지되지 않고 이를 인식하고 오류를 처리할 수 있도록 필요한 조치를 취할 수 있음  
> C++, Java, Ada : 지원 o
> C, Fortran : 지원 x

> **3. Aliasing**  
> 메모리의 한 저장 장소를 여러 이름으로 접근할 수 있는 기능    
> ex) union {int n; float x;};  
> 서로 다른 변수가 같은 저장 장소를 접근 할 수 있음 (신뢰성에 부정적인 영향을 끼침)  

> **4. Readability and Writability(가독성과 작성력)**
> 가독성과 작성력이 뛰어난 언어로 작성된 프로그램은 오류 가능성이 적다.

### **Cost(비용)** ###
시간 및 경비가 얼마나 필요한가?
**1. 프로그래머 양성 비용**
* 간결성과 직교성의 영향을 받음
* 프로그래머 새로운 언어를 배울 때 쉽게 습득 가능

**2. 프로그램 개발 비용(중요)**
* 작성력과 특정 응용분야와의 밀집성의 영향을 받음
* 개발할 domain에 맞는 언어를 쓰는 것이 개발에 중요한 영향을 끼침

**3. 프로그램 컴파일 비용**
* 프로그램 컴파일 시 소요되는 메모리나 시간

**4. 프로그램 실행 비용**
* 어떠한 기능을 어떠한 언어로 설계할 것인지 상호 밀접한 관계를 가짐
* compile 비용과 trade-off 관계(상호 반대)
* 최적화(optimization)하면, 컴파일 시간이 길어져 컴파일 비용은 높아지나, 실행 비용은 낮아진다.
  
**5. 컴파일/interpreter 비용**
* 언어 구현 시스템이 무료 또는 저렴한 경우, 널리 사용됨(Java)
* 언어 구현 시스템이 고가인 경우, 잘 사용되지 않음(Ada)

**6. 신뢰성(중요)**
신뢰도가 낮은 언어로 작성된 프로그램은 오류로 인한 비용 부담이 크다.

**7. 유지보수 비용(중요)**
-개발하는 언어에 의해 유지보수 비용이 달라짐  
-가독성과 작성력의 영향을 받음  
  
<Computer common knowledge>
---------------------------

### **중앙처리장치(cpu)** ### 

	* 명령어 인출(Instruction Fetch) 메모리로부터 명령어를 읽어온다. 
	* 명령어 해독(Instruction Decode) 제어장치(Control unit)가 명령어를 해독한다.
		
	* 데이터 인출(Data Fetch) 해독한 명령어가 데이터가 필요한 경우 메모리나 외부장치로부터 데이터를 읽어온다
	* 데이터 처리(Data Process) 산술 및 논리장치(ALU)에서 데이터에 대한 산술적 혹은 논리적 연산 수행한다.
	* 데이터 쓰기(Data Store) 데이터 처리가　끝난 수행 결과를 메모리가 저장한다.

### **cpu = control unit +alu+ register(cpu의 임시기억장치)** ###

### **명령어 사이클(Instruction cycle)** ###  
> 명령어 인출(인출 사이클) + 명령어 실행(실행 사이클)
> 중앙처리장치가 한 개의 명령어를 실행하는데 필요한 전체 처리 과정으로서, cpu가 프로그램 실행을 시작한 순간부터 끝까지 반복

### **cpu register** ###

### **프로그램 카운터(pc)** ###
> * 다음에 인출할 명령의 주소를 가지고 있는 레지스터
> * 각 명령어가 인출된 후에는 자동적으로 일정 크기(명령어 길이)만큼 증가 +4
> * 분기 명령어가 실행되는 경우에는 목적지 주소로 갱신

### **누산기(ac)** ###
> * 데이터를 일시적으로 저장하는 레지스터
> * alu의 결과값을 저장
> * 레지스터 크기는 cpu가 한 번에 처리할 수 있는 데이터 비트 수

### **명령어 레지스터(ir)** ###
> * 가장 최근에 인출된 명령어 코드가 저장되어 있는 레지스터

### **명령어 실행에 필요한 cpu 내부 레지스터들** ###
> * 기억장치 주소 레지스터(mar)
> *명령어 인출 단계에서 cpu에서 memory에 명령어 주소를 인출하는데 바로 가져오지 않고 mar에 일시적으로 저장하여 전달

> * 기억장치 버퍼 레지스터(mbr)
> *mar과 반대 개념으로 메모리에서 명령어 주소를 cpu로 전달하는데 mbr에 일시적으로 거침

### **명령어 형식** ###

연산코드(op code) + 오퍼렌트(operand) 
연산 코드 + 오퍼랜드
연산 코드 : cpu가 수행할 연산을 지정
오퍼랜드 : 명렁어 실행에 필요한 데이터가 저장된 주소

명령어 사이클의 예
cpu가 pc에 저장된 다음 실행될 명령어 주소를 mar을 거치고 메모리로 보내서 메모리에서 명령어 코드를 mbr에 임시 저장 후 ir에 저장(instruction fetch)
ir에 저장된 명령어 코드가 load(op code)+addr(operand)인 경우
cu(명령어 코드 해석 + 명령어를 실행하기 위한 명령을 내림)
1. cu가 ir에 있는 명령어를 해석해보니 addr에서 데이터가 필요함 
그래서 메모리로부터 데이터를 가져와야 함
2. addr을 mar에 보내고 메모리에서 필요한 데이터를 mbr을 통해 보내고 전송한 데이터가 ac에 일시적으로 저장됨(fetch)

ex) store accumulator address 명령어
ac에 있는 내용을 address에 저장해라

ir에 있는 저장할 address(operand)를 mar로 전송함
mar에 저장된 주소를 메모리에서 찾음
ac에 저장되있는 데이터를 mbr로 보낸 후 데이터를 메모리에 저장

ex) add address 명령어
1. ir(address)->mar->memory(data)
2.memeory->mbr->ac

### **명령어 파이프라이닝** ###

명령어 사이클을 독립적으로 여러 단계별로 나누는 것을 말한다.
한 클록에 두 개의 일을 수행하기 때문에 2배 빠를 것으로 기대함.
문제점 : 두 단계의 처리 시간이 동일하지 않으면 두 배의 속도 향상을 얻지 못함
해결책 : 파이프라인 단계의 수를 증가시켜 각 단계의 처리 시간을 같게 함.
- 파이프라인 단계의 수를 늘리면 전체적으로 속도가 향상됨.
ex>2단계 명령어 파이프라인 인출 단계와 실행 단계라는 두 개의 독립적인 파이프라인 모듈로 분리 가능

두 단계들에 동일한 클록을 가하여 동작 시간을 일치시킨다.
명령어->인출단계->명령어->실행단계->실행결과

ex> 4단계 명령어 파이프라인

명령어 인출 단계
명령어 해독 단계
오퍼랜드 인출 단계
실행 단계

**명령형 언어(컴파일러형 언어)**
폰 노이만 구조에 기반하여 변수,배정문,반복문 등의 명령어를 순차적, 절차적으로 수행
함수 호출 순서에 종속적인 특징을 갖고 있다.
프로그램을 복잡하고 이해하기 어렵게 만들 수 있다.

**함수형 언어(인터프리터형 언어)**
데이터를 함수에 적용하여 사용
LISP
일반적인 리스트 구조와 함수의 적용을 기본
간결하고 이해하기 쉬운 특징을 가지며 프로그램의 형식적인 분석과 조작이 용이

데이터지향 프로그램 설계 방법론
문제 해결을 위해 추상 데이터 타입의 사용에 중점을 두면서 데이터 설계를 강조
객체지향 방법론<->프로세스지향 프로그래밍
동시성 분야에서 이루어짐
동시에 수행되는 프로그램 단위를 생성하고 제어하기 위한 언어 기능에 대한 필요성을 불러일으킨다.

**프로그래밍 방법론**
> 1950~1960년 초반 :  
> 1960년 후반 : 하드웨어 비용은 감소하나 소프트웨어 비용은 증가하는데 프로그래머의 생산성 향상은 적었고 컴퓨터에 해결되는 문제의 규모는 커지면서 하향식 설계와 단계적 세분화라는 방법론이 등장했다. 이 당시 사용되는 언어의 주요 결함은 타입 검사의 불안전성과 제어문의 부적절성(goto)이었다.
> 1970년 : 프로세스지향 프로그램 설계 방법론에서 데이터지향 프로그램 설계 방법론으로 변화
  추상화 데이터 타입 사용
> 1980년 : 객체지향 설계(데이터 추상화 + 상속 + 동적 바인딩)

ex)smalltalk 
언어 부류
명령형 언어
명령형 언어(프로시저지향)에서 객체지향 프로그래밍을 지원하기 위하여 c와 java의 표현식(variables), 배정문(assignment statements), 제어문(iteration)은 거의 동일하다.
GUI를 생성할 수 있는 비주얼 언어
스크립트 언어
EX) C, java, perl, javascript, visual basic .net, c++
함수형 언어(applicative, functional)
주요 계산 표현 수단인 주어진 매개변수에 함수를 적용하는 언어
ex)LISP, Scheme, ML, F#
논리형 언어
규칙-기반 언어이다. 특정 순서 없이 명세되며, 요구된 결과에 맞춰 실행 순서를 선택한다.
ex) Prolog
마크업/하이브리드 언어
ex) XHTML, XML, JSTL, XSLT 프로그래밍을 돕기 위해 만들어졌다.

프로그래밍 언어 평가 기준(language evaluation criteria)는 언어 설계를 위한 프레임워크를 제공한다.(설계 절충)

**1. 신뢰성(reliability) vs 실행 비용(cost of execution)**
Java 언어는 배열 첨자들이 모두 적법한 범위에 속하는지 참조 검사가 되어야 한다. 이는 실행 비용을 증가시키지만 신뢰성을 증가시키기에 둘이 상반된다.

**2. 판독성(readability) vs 작성력(writability)**
APL은 연산자들이 상당히 많기 때문에 길고 복잡한 표현식을 가능케 하지만 작성한 사람 외에는 읽을 수 없어 판독성이 굉장히 낮다.

**3. 작성력(writability) vs 신뢰성**
c++의 포인터는 다양한 방식으로 조작될 수 있기 때문에 신뢰성의 문제를 내포하지만 매우 융통성있는 효율적인 작성력을 제공한다.

언어 구현 시스템은 운영체제와 인터페이스를 갖음으로써 기본적으로 기계 언어 인터페이스에 대한 상부층을 형성한다. 이를 각각 언어의 컴파일러의 가상 컴퓨터로 취급할 수 있다.

구현 방법
-컴파일(copilation = compiler implementation) 
고급언어(원시 언어)->기계언어
ex) c, cobol, ada와 같은 언어들은 컴파일러 사용
1. 어휘 분석기(lexical analyzer)
	원시 프로그램에 포함된 문자들을 어휘 단위(lexcial unit)들로 모은다. 식별자(identifiers), 특수어(special words), 연산자(operators), 구분자(punctuation symbols) 기호로 구분된다.
2. 구문 분석기(syntax analyzer)
	어휘 단위들로 파스 트리(parse tree) 계층 구조 형성하여 프로그램의 구문 구조를 표현한다.
3. 중간 코드 생성기(intermediate code generator)
	원시 언어와 기계 언어 중간 수준의 언어로 표현된 프로그램 생성(어셈블리어와 매우 유사) 의미 분석기(semantic analyzer)은 타입 오류와 같은 구문 분석기에서 탐지하기 어려웠던 오류를 검사한다.

4. 코드 생성기(code generator)
	최적화(optimization)된 중간 코드 버전을 기계 언어 프로그램으로 변환한다.
5. 심볼 테이블(symbol table)
	데이터 베이스로 사용된다. 프로그램에 포함된 각 사용자-정의 이름에 대한 타입과 속성의 정보이다. 어휘 분석기와 구문 분석기에 의해서 저장되고, 의미 분석기와 코드 생성기에서 사용된다.

컴파일된 파일을 오브젝트 파일이라고 한다.(object file)
일반적으로 하나의 프로그램은 여러 개의 오브젝트 파일과 공용 라이브러리로 조합이 되며, 컴퓨터가 실행할 수 있도록 하나의 프로그램을 완성하기 위한 작업을 링킹(linking)이라고 부른다. 결국, 컴파일 과정(기계어로 변환)과 링킹 과정(오브젝트 파일을 라이브러리와 합쳐 하나의 프로그램)을 거치면서 실행 파일(exe)이 되는 것이다. 이는 링커(linker)가 수행한다.
완성된 파일(exe)을 실행하면 컴퓨터는 해당 프로그램의 내용을 메모리에 적재(load)시키고, 프로그램을 수행한다. 이는 로더(loader)가 수행한다.

### **폰 노이만 병목(Von Neumann Bottleneck)** ###
기억장소(메모리)와 프로세서(cpu)를 연결(폰 노이만 병목)하는 속도는 보통 컴퓨터의 속도를 결정한다.
언어에 대한 가상 기계를 제공한다.
-순수해석(pure interpretation)
컴파일 과정과는 정반대로 인터프리터(interpreter)에 의해서 해석된다. 인터프리터 프로그램은 기계의 소프트웨어 모의실험으로서 동작하고 이 경우의 인출-실행 사이클은 고급 언어로 표현된 프로그램 문장을 다룬다.
원시 수준 디버깅 연산을 쉽게 구현할 수 있다. 그러나 컴파일된 시스템보다 느리다. 고급 언어 문장을 매번 해석해야되기 때문이다. 또한 더 많은 기억공간을 요구한다.
ex) apl, snobol, lisp, javascript, php

-혼합형 구현 시스템(hybrid implementation systems)
컴파일러+순수해석 방식
중간 언어 코드(어셈블리어)를 기계 코드로 번역하는 대신에 중간 코드를 단순히 해석한다.
원시 언어 문장이 단지 한번만 해독되기 때문에 순수 해석보다 빠르다.
ex)Perl : 해석 과정 전에 오류를 탐지하고 인터프리터를 단순화하기 위해 부분적으로 번역된다.
 java: 바이트 코드라 불리는 중간 코드는 바이트 코드 인터프리터에 의해 해석되고 관련된 실행 시간 시스템을 통합하여 자바 가상 기계(jvm)라 부른다. JIT(Just-in-Time) 구현 시스템은 먼저 프로그램을 중간 언어로 번역하고, 프로그램 실행 중에 중간 언어 메소드가 호출될 때, 그 메소드를 기계 코드로 번역한다. 번역된 기계 코드 버전은 다음의 호출에 대비하여 유지된다. ex) java프로그램, .NET언어에서 사용된다.
개발자는 프로그램을 개발하고 디버깅하는데 인터프리터를 사용하고 컴파일은 프로그램이 버그가 적고 실행속도를 향상하기 위할 때 사용된다.

사전처리기(Preprocessors)
프로그램이 번역되기 직전에 프로그램을 처리하는 프로그램이다. 일반적으로 매크로 확장기(macro expander)가 포함된다. 사전처리기 명령어는 일반적으로 다른 파일에 속한 코드가 현재 프로그램에 포함되어야 한다고 명세하는데 사용된다.
ex)#include myLib.c
   #define max(a,b) ((a)>(b)?(a):(b))
 

### **프로그래밍 환경(Programming Environments)** ###
소프트웨어를 개발하는데 개발언어 뿐만 아니라 프로그래밍 환경도 굉장히 중요하다. 프로그래밍 환경은 개발에 사용되는 도구들의 모임인데 사용자 인터페이스를 통하여 사용 가능한 통합된 도구들로 구성되어 소프트웨어를 개발하는데 사용되면 개발하는데 유용하다.
ex)unix : 다양한 언어를 사용한 소프트웨어의 생산과 유지보수를 위한 강력한 지원 도구를 제공한다. GUI(graphical user interface)를 통해서 사용된다.
__Borland JBuilder__ : Java 개발을 위해서 하나로 통합된 프로그래밍 환경이다. 그래픽 인터페이스를 통하여 제공된다.
__Visual Studio.NET__ : 윈도우 인터페이스를 통해서 제공된다.
